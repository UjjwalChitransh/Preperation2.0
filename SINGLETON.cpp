#include <mutex>
//The static local variable initialization is already guaranteed to be thread-safe in C++11 and later.
//This means that the compiler and runtime guarantee that the static local variable instance is initialized in a thread-safe manner
//In the context of a static local variable, its initialization is already thread-safe, and the use of std::mutex in this specific case might be redundant.
class Singleton {
    private:
            //In the context of C++ class definitions, the default keyword is used to specify that a special member function (such as a constructor or a destructor) should be generated by the compiler with the default behavior.
            Singleton()=default; //Prevent direct instantiation
            //The copy constructor and assignment operators are declared as delete, preventing the creation of copies of the singleton instance.
            Singleton(const Singleton&)=delete;//Preent copy constructor
            Singleton& operator=(const Singleton&)=delete;//Prevent assignment operator
            Singleton(Singleton&&)=delete;//Prevent move constructor
            Singleton& operator=(Singleton&&)=delete;//Prevent move assignment operator

           //The getInstance() method doesn't require any synchronization mechanisms as the instance is local to the method and is created only once upon the first call. This ensures that multiple threads attempting to access the instance simultaneously won't cause conflicts.
            static Singleton& instance(){
                static Singleton instance; //Local variable
                return instance;
            }

            std::mutex mutex;//Mutex to protect the getInstance() method


    public:
        ~Singleton()=default; // Destructor
        //other methods and data members
        void someMethod(){
            //Implementation of someMethod
        }
        static Singleton& getInstance(){
            return instance;
        }
}
